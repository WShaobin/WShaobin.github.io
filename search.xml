<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git工作流程+常用命令]]></title>
    <url>%2F2019%2F10%2F24%2Fgit-command%2F</url>
    <content type="text"><![CDATA[Git工作流程+常用命令流程图 Git工作流程 以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Git常用命令查看远程仓库地址：git remote -v 修改远程地址：git remote set-url origin http://xxxx/xxx.git(后面是新地址) 参考 Git最全命令]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome打开应用商店及推荐实用插件]]></title>
    <url>%2F2019%2F01%2F08%2Fchrome-plugin%2F</url>
    <content type="text"><![CDATA[解决Chrome打不开的问题，推荐开发使用的优质插件 解决方案 通过修改hosts文件等等 谷歌访问助手，根据自己使用的浏览器点击对应版本的插件，下载地址 实用插件 二维码(QR码)生成器 模拟其他浏览器访问的谷歌浏览器 网络请求：Postman 过滤广告：Adblock Plus 方便 github 项目结构查看 json结构树查看 划词翻译]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git上传本地项目到Github]]></title>
    <url>%2F2018%2F12%2F22%2Fgit-upload-project%2F</url>
    <content type="text"><![CDATA[全网最详细的介绍，如何用Git的方式把项目上传本地项目到Github 创建本地版本库其实这里就是你要上传的那个项目文件（例如：Project） Git初始化对着Project右键,选择Git bash here,通过命令git init把这个文件夹变成Git可管理的仓库 这时你会发现Project里面多了个.git文件夹，它是Git用来跟踪和管理版本库的。如果你看不到，是因为它默认是隐藏文件，那你就需要设置一下让隐藏文件可见。 项目添加到本地仓库你的项目粘贴到这个本地Git仓库里面（粘贴后你可以通过git status来查看你当前的状态），然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态。 提交到仓库用git commit把项目提交到仓库，-m后面引号里面是本次提交的注释内容,命令如下 git commit -m &quot;注解内容&quot; 下面就是上传了，如果没有配置SSH的话，可以先配置一下，这里不做详细的介绍了 创建远程仓库在Github上创建一个Git仓库，你可以直接点New repository来创建，比如我创建了一个Project的仓库 关联本地仓库在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地Project仓库的命令行输入： git remote add origin https://github.com/WShaobin/Project.git 这里可以是HTTPS或者SSH,二则选其一就行 推送到远程仓库关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过： git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了： git push origin master 至此就完成了将本地项目上传到Github的整个过程。 另外，如果你在git push 的时候出现如下报错。 原因是你勾选了Initialize this repository with a README，就是创建仓库的时候自动给你创建一个README文件，而本地仓库没有README文件，这时我们可以通过以下命令先将内容合并以下： git pull --rebase origin master 然后重新push就成功了 Git忽略遇到的问题在添加.gitignore文件后，当想push文件的时候，声明的忽略文件还是会出现在push的目录中 原因分析某些文件已经被纳入版本管理中，就算是在.gitignore中已经声明也不会起作用 解决方案我们应该先把本地的缓存删除，然后再进行push，操作步骤如下 123git rm -r --cached . // 删除本地缓存git add . // 添加要提交的文件git commit -m 'update .gitignore' // 更新本地的缓存 总结初次上传12345git initgit add .git commit -m "注解内容"git remote add origin https://github.com/xxx/xxx.gitgit push -u origin master 如果git push时，报了git pull…的错，可以使用如下命令： 1git pull --rebase origin master 二次上传123git add .git commit -m "注解内容"git push origin master 参考 Git上传项目]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android反编译Apk，修改资源，重新打包，签名发布]]></title>
    <url>%2F2018%2F12%2F22%2Fdecompile-apk-1%2F</url>
    <content type="text"><![CDATA[本文简单介绍apk是如何修改logo（ic_launcher），类似的资源文件修改也可以通过此方式。不过要修改class的话就要涉及到smali的学习了，这里就暂且不谈，后续有需要再做更新。 工具介绍 apktool：用来反编译apk，apk重新打包 autosign：自动签名工具，将重新打包的apk进行签名，如果不签名，无法安装使用 jadx-0.6.1-dev-build226：查看源码及目录结构，相当于dex2jar + jd-gui这些工具在网上都可以下载的到，如果需要的话留下邮箱即可 工具使用jadx-0.6.1-dev-build226双击jadx-0.6.1-dev-build226\bin目录下jadx-gui.bat,选择test.apk即可看到源码及目录结构，如下这只是用于查看源码，并起不到修改作用，不过可以查看要修改的东西在哪个位置，真正修改要通过apktool反编译apk的源码才可以修改。 apktool 该目录下有三个文件：aapt.exe，apktool.bat，apktool.jar ，将需要反编译的APK文件放到该目录下，如图：在该目录下，按住Shift，然后右键选择“在此处打开命令窗口”，输入一下命令： apktool.bat d -f test.apk -o test apktool -f [待反编译的apk] -o [反编译之后存放文件夹]如果反编译过程中遇到Exception in thread “main” 错误，可能是apktool.jar的版本太低，使用高版本不会出现异常。 请往https://ibotpeaches.github.io/Apktool/ 重新下载，下载到的apktool_xxx.jar文件改名为apktool.jar，然后替换掉老版本的apktool.jar，重新执行命令应该就正常了。 反编译之后会得到test 文件夹，打开test文件夹，里边就是反编译出来的各种资源文件然后进行test\res目录去修改ic_launcher，这里所有的ic_launcher都要做替换。 修改成功，保存，重新打包，执行打包命令 apktool.bat b test 在test文件内会多出两个文件如下图所示：dist文件内就是我们需要的apk。 autosign签名apk，重新发布 接下来就要用到签名工具了，如果不经过签名是不能正确运行的。工具： auto-sign.zip 将打包好的test.apk 拷贝到解压好的auto-sign文件夹下，执行命令： java -jar signapk.jar testkey.x509.pem testkey.pk8 test.apk test_signed.apk test_signed.apk就是签名后的apk 到此修改资源文件就大功告成了，也是很简单的 参考：https://blog.csdn.net/sxk874890728/article/details/80486223]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next的个性化教程，打造炫酷网站]]></title>
    <url>%2F2018%2F12%2F20%2Fhexo-2%2F</url>
    <content type="text"><![CDATA[在学习搭建Hexo网站的时候，看到很多人用着炫酷的效果,特意搜了一下，发现网上确实有很多教程，这里就不一一说明，只列举处对应的功能。 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景(themes\next\_config.yml搜canvas_把值改为true) 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 添加网易云跟帖(跟帖关闭，已失效，改为来必力) 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享（jia this已经宣布关闭，个人用的是baidushare） 修改字体大小 修改打赏字体不闪动 自定义鼠标样式 为博客加上萌萌的宠物（注意：_config.yml是根目录的） DaoVoice 在线联系 点击爆炸效果 添加更多的menu内容 添加网易云音乐 (其中id为歌单Id) 文章置顶+置顶标签 当前浏览进度 themes\next\_config.yml搜scrollpercent改为true。 如果想要在侧边栏显示，则搜b2t改为true RSS下的社交平台 在themes\next\_config.yml中搜索social,开启social及修改对应的值 平台链接后面的||指的是Font Awesome图标字体库 123456789social: GitHub: https://github.com/WShaobin || github E-Mail: http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=EyQnISAqJSslJFNiYj1wfH4 || envelope CSDN: https://blog.csdn.net/qq_30552993 || codiepie 简书: https://www.jianshu.com/u/c9c7b1275142 || gratipaysocial_icons: enable: true icons_only: false transition: false 添加友情链接 进入themes\next\layout\_macro\slidebar.swig 123&#123;% if theme.social %&#125;......&#123;% endif %&#125; 这以上代码下添加下面内容，修改成自己想要的内容 123456789101112&lt;div class="links-of-blogroll motion-element links-of-blogroll-inline"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;i class="fa fa-fw fa-globe"&gt;&lt;/i&gt; 友情链接 &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; &lt;li class="links-of-blogroll-item"&gt; &lt;a href="https://xxx" title="xxx" target="_blank"&gt;xxx&lt;/a&gt; &lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt; 修改文章模版Front-matter 根目录scaffolds\post.md添加tags,categories等 1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: []categories: [] 添加cnzz站点统计 找到themes\next\layout\_partials\footer.swig，在内容的最上面添加统计代码&lt;script&gt;......&lt;/script&gt; 文章底部添加版权信息 开启方式：themes\next\_config.yml，搜post_copyright，将enable改成true 版权信息布局：themes\next\layout\_macro\post-copyright.swig 修改字体信息：themes\next\languages\zh-Hans.yml,搜索copyright 如果本文链接为http://yoursite.com，请到根目录_config.yml修改url为https://xxx.github.io （自己的网址） 参考:https://www.jianshu.com/p/f054333ac9e6http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建博客心得篇]]></title>
    <url>%2F2018%2F12%2F20%2Fhexo-1%2F</url>
    <content type="text"><![CDATA[以前都是在CSDN上写博客，就想着何时自己搭建一个博客，终于通过借鉴和看了很多大神的文章，开启了Hexo+Github搭建博客，这里跟大家分享一些心得。 安装和配置Node.jsNode.js官网 安装成功之后，打开cmd，运行以下两个命令12node -vnpm -v 出现对应的版本即表示安装成功，再运行1path 如果看到nodejs字样证明配置环境成功 安装和配置Git安装成功之后，桌面右键选择Git Bash Here,运行以下命令 1$ git --version 出现对应的版本号，说明已经成功了。 Github上新建项目在Github右上角【+】，选择new repository。项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。(https:// 账户名.github.io) 安装Hexo1、在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。 然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo，不过很卡请看第二点 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 2、如果npm安装Hexo卡顿，npm使用国内镜像，以管理员身份运行命令提示符 换成阿里源npm config set registry https://registry.npm.taobao.org 验证命令npm config get registry //返回https://registry.npm.taobao.org，说明镜像配置成功。 安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org 3、看到后面的“Start blogging with Hexo！”，则说明初始化成功。 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 注意：开启之后，别把cmd窗口关闭，要不然就访问不了http://localhost:4000 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 Git绑定Github账号在blog文件里面，右键Git Base Here123$ git config --global user.name “账号”$ git config --global user.email “邮箱”$ cd ~/.ssh 输入ls，如果出现id_ras id_ras.pub….，则表示密钥已存在 若不存在，则输入ssh-keygen -t rsa -C “xxx@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 登录Github，点击头像下的settings，点击侧边栏SSH and GPG keys，再点击Add SSH Key，在title处填入任意的标识，在Key部分里面添加刚才复制的id_rsa.pub文件里的内容，点击添加即可 输入ssh -T git@github.com，测试添加ssh是否成功 配置Deployment在blog目录下，找到_config.yml文件，修改repo值（在末尾）1234deploy: type: git repository: git@github.com:WShaobin/WShaobin.github.io.git branch: master repository值是你在github项目里的ssh（右下角） 新建一篇博客右键git bash here执行命令：hexo new post “文章”或hexo new “文章” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 添加搜索功能进入blog目录，右键git bash here，执行命令：npm install hexo-generator-searchdb --save 修改根目录下的_config.yml，在最底部添加如下配置12345search: path: search.xml field: post format: html limit: 10000 修改主体下的themes\next_config.yml配置文件（我的目录：blog\themes\next_config.yml） 搜索local_search，修改enable为true 预览效果，开启本地server hexo clean (清除缓存文件 (db.json) 和已生成的静态文件 (public))hexo g（生成静态文件）hexo s（启动服务器） 按下 Ctr+C to stop 部署到线上hexo ghexo d （部署到线上服务器）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 蓝牙设备通讯的开发(配对/连接/传输数据)]]></title>
    <url>%2F2018%2F12%2F19%2Fble-2%2F</url>
    <content type="text"><![CDATA[最近公司想做一个关于蓝牙的项目,同时我也学习到了很多关于蓝牙方面的很多知识点,希望在这里跟大家分享下,不足之处有望指明. 这里先附上项目图片,不过这里ListView中如果是已配对的就进行连接,如果是未配对的就进行配对,配对完成之后这里的话要重新搜索设备,这里没做刷新.还有就是可以在两只手机上都装上这个,再连接上就可以进行发送到另一只手机上去,不知道为什么有时候好像蓝牙有些不知是否不太稳定,出现搜索蓝牙有些没搜到. 在很多方面，蓝牙是一种能够发送或接受两个不同的设备之间传输的数据。 Android平台包含了蓝牙框架，使设备以无线方式与其他蓝牙设备进行数据交换的支持。 项目源码 Android提供蓝牙API来执行这些不同的操作。 扫描其他蓝牙设备 获取配对设备列表 连接到通过服务发现其他设备 Android提供BluetoothAdapter类蓝牙通信，通过调用创建的对象的静态方法getDefaultAdapter。其语法如下:12private BluetoothAdapter mBA;mBA = BluetoothAdapter.getDefaultAdapter(); 这里我把一些关于蓝牙的打开/关闭/配对/连接/数据传输的线程都封装BlueToothUtils这个蓝牙工具类中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothServerSocket;import android.bluetooth.BluetoothSocket;import android.content.Context;import android.os.Handler;import android.os.Message;import android.util.Log;import android.widget.Toast;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;import java.util.Set;import java.util.UUID;/** * Created by shaolin on 5/23/16. */public class BlueToothUtils &#123; private static final String TAG = "BlueToothUtils"; private Context mContext; public static BlueToothUtils sInstance; private BluetoothAdapter mBA; // UUID.randomUUID()随机获取UUID private final UUID MY_UUID = UUID .fromString("db764ac8-4b08-7f25-aafe-59d03c27bae3"); // 连接对象的名称 private final String NAME = "LGL"; // 这里本身即是服务端也是客户端，需要如下类 private BluetoothSocket mSocket; private BluetoothDevice mOldDevice; private BluetoothDevice mCurDevice; // 输出流_客户端需要往服务端输出 private OutputStream os; //线程类的实例 private AcceptThread ac; public static synchronized BlueToothUtils getInstance() &#123; if (sInstance == null) &#123; sInstance = new BlueToothUtils(); &#125; return sInstance; &#125; public BlueToothUtils() &#123; mBA = BluetoothAdapter.getDefaultAdapter(); ac = new AcceptThread(); &#125; public void setContext(Context context) &#123; this.mContext = context; &#125; public BluetoothAdapter getBA() &#123; return mBA; &#125; public AcceptThread getAc() &#123; return ac; &#125; public BluetoothDevice getCurDevice() &#123; return mCurDevice; &#125; /** * 判断是否打开蓝牙 * * @return */ public boolean isEnabled() &#123; if (mBA.isEnabled()) &#123; return true; &#125; return false; &#125; /** * 搜索设备 */ public void searchDevices() &#123; // 判断是否在搜索,如果在搜索，就取消搜索 if (mBA.isDiscovering()) &#123; mBA.cancelDiscovery(); &#125; // 开始搜索 mBA.startDiscovery(); Log.e(TAG, "正在搜索..."); &#125; /** * 获取已经配对的设备 * * @return */ public List&lt;BluetoothDevice&gt; getBondedDevices() &#123; List&lt;BluetoothDevice&gt; devices = new ArrayList&lt;&gt;(); Set&lt;BluetoothDevice&gt; pairedDevices = mBA.getBondedDevices(); // 判断是否有配对过的设备 if (pairedDevices.size() &gt; 0) &#123; for (BluetoothDevice device : pairedDevices) &#123; devices.add(device); Log.e(TAG, "BondedDevice:" + device.getName()); &#125; &#125; return devices; &#125; /** * 与设备配对 * * @param device */ public void createBond(BluetoothDevice device) &#123; try &#123; Method createBondMethod = BluetoothDevice.class.getMethod("createBond"); createBondMethod.invoke(device); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 与设备解除配对 * * @param device */ public void removeBond(BluetoothDevice device) &#123; try &#123; Method removeBondMethod = device.getClass().getMethod("removeBond"); removeBondMethod.invoke(device); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param device * @param str 设置PIN码 * @return */ public boolean setPin(BluetoothDevice device, String str) &#123; try &#123; Method removeBondMethod = device.getClass().getDeclaredMethod("setPin", new Class[]&#123;byte[].class&#125;); Boolean returnValue = (Boolean) removeBondMethod.invoke(device, new Object[]&#123;str.getBytes()&#125;); Log.e("returnValue", "" + returnValue); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true; &#125; /** * 取消用户输入 */ public boolean cancelPairingUserInput(BluetoothDevice device) &#123; Boolean returnValue = false; try &#123; Method createBondMethod = device.getClass().getMethod("cancelPairingUserInput"); returnValue = (Boolean) createBondMethod.invoke(device); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; // cancelBondProcess() return returnValue.booleanValue(); &#125; /** * 取消配对 */ public boolean cancelBondProcess(BluetoothDevice device) &#123; Boolean returnValue = null; try &#123; Method createBondMethod = device.getClass().getMethod("cancelBondProcess"); returnValue = (Boolean) createBondMethod.invoke(device); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return returnValue.booleanValue(); &#125; /** * @param strAddr * @param strPsw * @return */ public boolean pair(String strAddr, String strPsw) &#123; boolean result = false; mBA.cancelDiscovery(); if (!mBA.isEnabled()) &#123; mBA.enable(); &#125; if (!BluetoothAdapter.checkBluetoothAddress(strAddr)) &#123; // 检查蓝牙地址是否有效 Log.d("mylog", "devAdd un effient!"); &#125; BluetoothDevice device = mBA.getRemoteDevice(strAddr); if (device.getBondState() != BluetoothDevice.BOND_BONDED) &#123; Log.d("mylog", "NOT BOND_BONDED"); try &#123; setPin(device, strPsw); // 手机和蓝牙采集器配对 createBond(device); result = true; &#125; catch (Exception e) &#123; Log.d("mylog", "setPiN failed!"); e.printStackTrace(); &#125; // &#125; else &#123; Log.d("mylog", "HAS BOND_BONDED"); try &#123; createBond(device); setPin(device, strPsw); // 手机和蓝牙采集器配对 createBond(device); result = true; &#125; catch (Exception e) &#123; Log.d("mylog", "setPiN failed!"); e.printStackTrace(); &#125; &#125; return result; &#125; /** * 获取device.getClass()这个类中的所有Method * * @param clsShow */ public void printAllInform(Class clsShow) &#123; try &#123; // 取得所有方法 Method[] hideMethod = clsShow.getMethods(); int i = 0; for (; i &lt; hideMethod.length; i++) &#123; Log.e("method name", hideMethod[i].getName() + ";and the i is:" + i); &#125; // 取得所有常量 Field[] allFields = clsShow.getFields(); for (i = 0; i &lt; allFields.length; i++) &#123; Log.e("Field name", allFields[i].getName()); &#125; &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 打开蓝牙 */ public void openBlueTooth() &#123; if (!mBA.isEnabled()) &#123; // 弹出对话框提示用户是后打开 /*Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, 1);*/ // 不做提示，强行打开 mBA.enable(); showToast("打开蓝牙"); &#125; else &#123; showToast("蓝牙已打开"); &#125; &#125; /** * 关闭蓝牙 */ public void closeBlueTooth() &#123; mBA.disable(); showToast("关闭蓝牙"); &#125; /** * 弹出Toast窗口 * * @param message */ private void showToast(String message) &#123; if (mContext != null) &#123; Toast.makeText(mContext, message, Toast.LENGTH_LONG).show(); &#125; else &#123; Log.e(TAG, "message:" + message); &#125; &#125; /** * 主动连接蓝牙 * * @param device */ public void connectDevice(BluetoothDevice device) &#123; // 判断是否在搜索,如果在搜索，就取消搜索 if (mBA.isDiscovering()) &#123; mBA.cancelDiscovery(); &#125; try &#123; // 获得远程设备 if (mCurDevice == null || mCurDevice != mOldDevice) &#123; mCurDevice = mBA.getRemoteDevice(device.getAddress()); mOldDevice = mCurDevice; Log.e(TAG, "device:" + mCurDevice); mSocket = mCurDevice.createRfcommSocketToServiceRecord(MY_UUID); // 连接 mSocket.connect(); // 获得输出流 os = mSocket.getOutputStream(); &#125; // 如果成功获得输出流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 传输数据 * * @param message */ public void write(String message) &#123; try &#123; if (os != null) &#123; os.write(message.getBytes("GBK")); &#125; Log.e(TAG, "write:" + message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 服务端，需要监听客户端的线程类 private Handler handler = new Handler() &#123; public void handleMessage(Message msg) &#123; showToast(String.valueOf(msg.obj)); Log.e(TAG, "服务端:" + msg.obj); super.handleMessage(msg); &#125; &#125;; // 线程服务类 public class AcceptThread extends Thread &#123; private BluetoothServerSocket serverSocket; private BluetoothSocket socket; // 输入 输出流 private OutputStream os; private InputStream is; public AcceptThread() &#123; try &#123; serverSocket = mBA.listenUsingRfcommWithServiceRecord(NAME, MY_UUID); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; // 截获客户端的蓝牙消息 try &#123; socket = serverSocket.accept(); // 如果阻塞了，就会一直停留在这里 is = socket.getInputStream(); os = socket.getOutputStream(); while (true) &#123; synchronized (this) &#123; byte[] tt = new byte[is.available()]; if (tt.length &gt; 0) &#123; is.read(tt, 0, tt.length); Message msg = new Message(); msg.obj = new String(tt, "GBK"); Log.e(TAG, "客户端:" + msg.obj); handler.sendMessage(msg); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 参考:http://www.yiibai.com/android/android_bluetooth.html http://www.cnblogs.com/jason-star/archive/2012/09/10/2678368.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android BLE最完整的工具类(扫描/连接/读写/通知设备)]]></title>
    <url>%2F2018%2F12%2F19%2Fble-1%2F</url>
    <content type="text"><![CDATA[这里只要是Android设备与BLE设备的通讯都可以共用，只需要该的就是uuid的值，还有就是ble设备提供商要出文档协议，看看是如何发命令跟接收命令的。 BleUtil工具中，有些地方我感觉还是要提示下 1、characterUUID1 、characterUUID2 、descriptorUUID 这三个是对应的收发命令的，跟找到要操作的BluetoothGattDescriptor（特性）。 在做这个项目的时候ble设备提供商给的文档中uuid，是短的，我实际我打印出来的是长的。其实短的那种是ios来的，而android就不一样咯。可以参考：Android与IOS的UUID的区别 2、sendWorkModel、sendStrength 这两个方法是用来发送命令的，传值都是byte[]数组；而接收命令的话通过receiveData方法进行解析得到的byte[]。这三个方法都是需要根据不同设备协议进行修改，这里只是为了案例展示。总的来说就是收发命令都是byte[] 关键概念Generic Attribute Profile (GATT)通过BLE连接，读写属性类小数据的Profile通用规范。现在所有的BLE应用Profile都是基于GATT的。 Attribute Protocol (ATT)GATT是基于ATT Protocol的。ATT针对BLE设备做了专门的优化，具体就是在传输过程中使用尽量少的数据。 每个属性都有一个唯一的UUID，属性将以characteristics and services的形式传输。 CharacteristicCharacteristic可以理解为一个数据类型，它包括一个value和0至多个对次value的描述（Descriptor）。 Descriptor对Characteristic的描述，例如范围、计量单位等。 ServiceCharacteristic的集合。例如一个service叫做“Heart Rate Monitor”， 它可能包含多个Characteristics，其中可能包含一个叫做“heart rate measurement”的Characteristic。 角色和职责Android设备与BLE设备交互有两组角色： 中心设备和外围设备（Central vs. peripheral）； GATT server vs. GATT client. Central vs. peripheral: 中心设备和外围设备的概念针对的是BLE连接本身。 Central角色负责scan advertisement。而peripheral角色负责make advertisement。 GATT server vs. GATT client: 这两种角色取决于BLE连接成功后，两个设备间通信的方式。 举例说明： 现有一个活动追踪的BLE设备和一个支持BLE的Android设备。 Android设备支持Central角色，而BLE设备支持peripheral角色。 创建一个BLE连接需要这两个角色都存在，都仅支持Central角色或者都仅支持peripheral角色则无法建立连接。 当连接建立后，它们之间就需要传输GATT数据。 谁做server，谁做client，则取决于具体数据传输的情况。 例如，如果活动追踪的BLE设备需要向Android设备传输sensor数据，则活动追踪器自然成为了server端； 而如果活动追踪器需要从Android设备获取更新信息，则Android设备作为server端可能更合适。 权限及feature和经典蓝牙一样，应用使用蓝牙，需要声明BLUETOOTH权限， 如果需要扫描设备或者操作蓝牙设置，则还需要BLUETOOTH_ADMIN权限： 12&lt;uses-permission android:name="android.permission.BLUETOOTH"/&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt; 除了蓝牙权限外，如果需要BLE feature则还需要声明uses-feature： 1&lt;uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/&gt; 按时required为true时，则应用只能在支持BLE的Android设备上安装运行； required为false时，Android设备均可正常安装运行，需要在代码运行时判断设备是否支持BLE feature 通讯设备的主要步骤设置权限—&gt;打开蓝牙—&gt;扫描设备—&gt;连接设备—&gt;读写数据+通知设备的状态改变—&gt;断开设备 BluetoothGatt的服务层次BluetoothGatt—&gt;BluetoothGattService(服务)—&gt;BluetoothGattCharacteristic(特征)—&gt;BluetoothGattDescriptor(特性) 下面的就是重点啦!工具类,工具类,工具类好听的话说三遍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318import android.annotation.TargetApi;import android.app.Activity;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothGatt;import android.bluetooth.BluetoothGattCallback;import android.bluetooth.BluetoothGattCharacteristic;import android.bluetooth.BluetoothGattDescriptor;import android.bluetooth.BluetoothGattService;import android.bluetooth.BluetoothManager;import android.bluetooth.BluetoothProfile;import android.content.Context;import android.content.pm.PackageManager;import android.os.Build;import android.os.Handler;import android.util.Log;import android.widget.Toast; import java.util.ArrayList;import java.util.List;import java.util.UUID; /** * Created by shaolin on 6/17/16. */@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)public class BleUtil &#123; private static final String TAG = "BleUtil"; private static final long SCAN_PERIOD = 10000; public static String characterUUID1 = "0000fff2-0000-1000-8000-00805f9b34fb";//APP发送命令 public static String characterUUID2 = "0000fff1-0000-1000-8000-00805f9b34fb";//BLE用于回复命令 private static String descriptorUUID = "00002902-0000-1000-8000-00805f9b34fb";//BLE设备特性的UUID public static byte[] workModel = &#123;0x02, 0x01&#125;; private Context mContext; private static BleUtil mInstance; //作为中央来使用和处理数据； private BluetoothGatt mGatt; private BluetoothManager manager; private BTUtilListener mListener; private BluetoothDevice mCurDevice; private BluetoothAdapter mBtAdapter; private List&lt;BluetoothDevice&gt; listDevice; private List&lt;BluetoothGattService&gt; serviceList;//服务 private List&lt;BluetoothGattCharacteristic&gt; characterList;//特征 private BluetoothGattService service; private BluetoothGattCharacteristic character1; private BluetoothGattCharacteristic character2; public static synchronized BleUtil getInstance() &#123; if (mInstance == null) &#123; mInstance = new BleUtil(); &#125; return mInstance; &#125; public void setContext(Context context) &#123; mContext = context; init(); &#125; public void init() &#123; listDevice = new ArrayList&lt;&gt;(); if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; showToast("BLE不支持此设备!"); ((Activity) mContext).finish(); &#125; manager = (BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE); //注：这里通过getSystemService获取BluetoothManager， //再通过BluetoothManager获取BluetoothAdapter。BluetoothManager在Android4.3以上支持(API level 18)。 if (manager != null) &#123; mBtAdapter = manager.getAdapter(); &#125; if (mBtAdapter == null || !mBtAdapter.isEnabled()) &#123; mBtAdapter.enable(); /*Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); mContext.startActivity(enableBtIntent);*/ &#125; &#125; //扫描设备的回调 private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; ((Activity) mContext).runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (!listDevice.contains(device)) &#123; //不重复添加 listDevice.add(device); mListener.onLeScanDevices(listDevice); Log.e(TAG, "device:" + device.toString()); &#125; &#125; &#125;); &#125; &#125;; //扫描设备 public void scanLeDevice(final boolean enable) &#123; if (enable) &#123; Handler mHandler = new Handler(); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; stopScan(); Log.e(TAG, "run: stop"); &#125; &#125;, SCAN_PERIOD); startScan(); Log.e(TAG, "start"); &#125; else &#123; stopScan(); Log.e(TAG, "stop"); &#125; &#125; //开始扫描BLE设备 private void startScan() &#123; mBtAdapter.startLeScan(mLeScanCallback); mListener.onLeScanStart(); &#125; //停止扫描BLE设备 private void stopScan() &#123; mBtAdapter.stopLeScan(mLeScanCallback); mListener.onLeScanStop(); &#125; //返回中央的状态和周边提供的数据 private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; Log.e(TAG, "onConnectionStateChange"); switch (newState) &#123; case BluetoothProfile.STATE_CONNECTED: Log.e(TAG, "STATE_CONNECTED"); mListener.onConnected(mCurDevice); gatt.discoverServices(); //搜索连接设备所支持的service break; case BluetoothProfile.STATE_DISCONNECTED: mListener.onDisConnected(mCurDevice); disConnGatt(); Log.e(TAG, "STATE_DISCONNECTED"); break; case BluetoothProfile.STATE_CONNECTING: mListener.onConnecting(mCurDevice); Log.e(TAG, "STATE_CONNECTING"); break; case BluetoothProfile.STATE_DISCONNECTING: mListener.onDisConnecting(mCurDevice); Log.e(TAG, "STATE_DISCONNECTING"); break; &#125; super.onConnectionStateChange(gatt, status, newState); &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; Log.d(TAG, "onServicesDiscovered"); if (status == BluetoothGatt.GATT_SUCCESS) &#123; serviceList = gatt.getServices(); for (int i = 0; i &lt; serviceList.size(); i++) &#123; BluetoothGattService theService = serviceList.get(i); Log.e(TAG, "ServiceName:" + theService.getUuid()); characterList = theService.getCharacteristics(); for (int j = 0; j &lt; characterList.size(); j++) &#123; String uuid = characterList.get(j).getUuid().toString(); Log.e(TAG, "---CharacterName:" + uuid); if (uuid.equals(characterUUID1)) &#123; character1 = characterList.get(j); &#125; else if (uuid.equals(characterUUID2)) &#123; character2 = characterList.get(j); setNotification(); &#125; &#125; &#125; &#125; super.onServicesDiscovered(gatt, status); &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; Log.e(TAG, "onCharacteristicRead"); super.onCharacteristicRead(gatt, characteristic, status); &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; Log.e(TAG, "onCharacteristicWrite"); super.onCharacteristicWrite(gatt, characteristic, status); &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; Log.e(TAG, "onCharacteristicChanged");// 这里是可以监听到设备自身或者手机改变设备的一些数据修改h通知 receiveData(characteristic); super.onCharacteristicChanged(gatt, characteristic); &#125; &#125;; //获取设备指定的特征中的特性,其中对其进行监听, setCharacteristicNotification与上面的回调onCharacteristicChanged进行一一搭配 private void setNotification() &#123; mGatt.setCharacteristicNotification(character2, true); BluetoothGattDescriptor descriptor = character2.getDescriptor(UUID.fromString(descriptorUUID)); descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mGatt.writeDescriptor(descriptor); &#125; //接收数据,对其进行处理 private void receiveData(BluetoothGattCharacteristic ch) &#123; byte[] bytes = ch.getValue(); int cmd = bytes[0]; int agree = bytes[1]; switch (cmd) &#123; case 1: mListener.onStrength(agree); Log.e(TAG, "手机通知BLE设备强度:" + agree); break; case 2: mListener.onModel(agree); Log.e(TAG, "工作模式:" + agree); break; case 3: mListener.onStrength(agree); Log.e(TAG, "设备自身通知改变强度:" + agree); break; &#125; &#125; //连接设备 public void connectLeDevice(int devicePos) &#123; mBtAdapter.stopLeScan(mLeScanCallback); mCurDevice = listDevice.get(devicePos); checkConnGatt(); &#125; //发送进入工作模式请求 public void sendWorkModel() &#123; if (character1 != null) &#123; character1.setValue(workModel); mGatt.writeCharacteristic(character1); &#125; &#125; //发送强度 public void sendStrength(int strength) &#123; byte[] strengthModel = &#123;0x01, (byte) strength&#125;; if (character1 != null) &#123; character1.setValue(strengthModel); mGatt.writeCharacteristic(character1); &#125; &#125; //检查设备是否连接了 private void checkConnGatt() &#123; if (mGatt == null) &#123; mGatt = mCurDevice.connectGatt(mContext, true, mGattCallback); mListener.onConnecting(mCurDevice); &#125; else &#123; mGatt.connect(); mGatt.discoverServices(); &#125; &#125; // 断开设备连接 private void disConnGatt() &#123; if (mGatt != null) &#123; mGatt.disconnect(); mGatt.close(); mGatt = null; listDevice = new ArrayList&lt;&gt;(); mListener.onLeScanDevices(listDevice); &#125; &#125; private void showToast(String message) &#123; Toast.makeText(mContext, message, Toast.LENGTH_SHORT).show(); &#125; public void setBTUtilListener(BTUtilListener listener) &#123; mListener = listener; &#125; public interface BTUtilListener &#123; void onLeScanStart(); // 扫描开始 void onLeScanStop(); // 扫描停止 void onLeScanDevices(List&lt;BluetoothDevice&gt; listDevice); //扫描得到的设备 void onConnected(BluetoothDevice mCurDevice); //设备的连接 void onDisConnected(BluetoothDevice mCurDevice); //设备断开连接 void onConnecting(BluetoothDevice mCurDevice); //设备连接中 void onDisConnecting(BluetoothDevice mCurDevice); //设备连接失败 void onStrength(int strength); //给设备设置强度 void onModel(int model); //设备模式 &#125;&#125; 参考:http://www.myext.cn/android/a_4699.html 重点:Android与IOS的UUID的区别]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 腾讯Bugly的应用升级&热更新]]></title>
    <url>%2F2018%2F12%2F19%2Fbugly-upgrade-update%2F</url>
    <content type="text"><![CDATA[经过去年的九月份至现在，发现自己很久没有写过比较好的文章了。今天就趁着通宵的劲，写一下对腾讯Bugly的应用升级&amp;热更新的理解，希望对新手有所帮助，有兴趣的可以了解下，没兴趣的也可以看完之后吐槽我。。。 Bugly 文档中心：https://bugly.qq.com/docs/ 官方文档写的还是蛮详细的，不过有些地方还是自己绕了很多弯，请教了公司大神才弄清楚的。 本篇文章已授权 玩Android 独家发布 项目配置的话，本人选择直接配置应用升级&amp;热更新。 配置gradleproject: build.gradle1234567891011121314151617181920212223242526buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4 classpath "com.tencent.bugly:tinker-support:1.1.1" &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; module: build.gradle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112apply plugin: 'com.android.application'// 热更新依赖插件脚本，如果不想要热更新可以注释掉apply from: 'tinker-support.gradle'//全局配置apply from: "../config.gradle"android &#123; compileSdkVersion compile_sdk_version buildToolsVersion build_tools_version defaultConfig &#123; applicationId "com.example.administrator.myapplication" minSdkVersion min_sdk_version targetSdkVersion target_sdk_version versionCode version_code versionName version_name testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" multiDexEnabled true multiDexKeepProguard file('multiDexKeep.pro') ndk &#123; // 设置支持的SO库架构 abiFilters 'armeabi', 'x86', 'armeabi-v7a', 'arm64-v8a' //, 'x86_64' &#125; javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath true &#125; &#125; &#125; signingConfigs &#123; debug &#123; keyAlias 'debug' keyPassword '123456' storeFile file('../debug.jks') storePassword '123456' v1SigningEnabled true v2SigningEnabled false &#125; release &#123; v1SigningEnabled true v2SigningEnabled false keyAlias 'key0' keyPassword '123456' storeFile file('../release.jks') storePassword '123456' &#125; &#125; buildTypes &#123; release &#123; debuggable log_debug shrinkResources false minifyEnabled false zipAlignEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release buildConfigField("boolean", "LOG_DEBUG", String.valueOf(log_debug)) &#125; debug &#123; debuggable true jniDebuggable true signingConfig signingConfigs.debug minifyEnabled false zipAlignEnabled false buildConfigField("boolean", "LOG_DEBUG", String.valueOf(log_debug)) &#125; &#125; dexOptions &#123;// incremental true// maxProcessCount 2 javaMaxHeapSize "4g" jumboMode = true &#125; lintOptions &#123; checkReleaseBuilds false abortOnError false &#125; sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125; &#125; repositories &#123; flatDir &#123; dirs 'libs' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support.constraint:constraint-layout:1.1.2' testCompile 'junit:junit:4.12' androidTestCompile 'com.android.support.test:runner:1.0.2' androidTestCompile "com.android.support:support-annotations:$support_library_version" compile "com.android.support:appcompat-v7:$support_library_version" compile "com.android.support:support-v4:$support_library_version" compile "com.android.support:multidex:1.0.3" // 多dex配置 //------------------Bugly--------------------------------------------------------- // compile 'com.tencent.bugly:crashreport_upgrade:latest.release' // compile 'com.tencent.bugly:nativecrashreport:latest.release' compile 'com.tencent.bugly:crashreport_upgrade:1.3.4' //升级SDK已经集成crash上报功能 compile 'com.tencent.bugly:nativecrashreport:3.3.1' //------------------Bugly---------------------------------------------------------&#125; tinker-support.gradle注：您需要在同级目录下创建tinker-support.gradle热更新配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091apply plugin: 'com.tencent.bugly.tinker-support'def bakPath = file("$&#123;buildDir&#125;/bakApk/")/** * 此处填写每次构建生成的基准包目录 */def baseApkDir = "app-0710-15-48-49"/** * 对于插件各参数的详细解析请参考 */tinkerSupport &#123; // 开启tinker-support插件，默认值true enable = true // 指定归档目录，默认值当前module的子目录tinker autoBackupApkDir = "$&#123;bakPath&#125;" // 是否启用覆盖tinkerPatch配置功能，默认值false // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch overrideTinkerPatchConfiguration = true // 编译补丁包时，必需指定基线版本的apk，默认值为空 // 如果为空，则表示不是进行补丁包的编译 // @&#123;link tinkerPatch.oldApk &#125; baseApk = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release.apk"// baseApk = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-debug.apk" // 对应tinker插件applyMapping baseApkProguardMapping = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-mapping.txt"// baseApkProguardMapping = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-debug-mapping.txt" // 对应tinker插件applyResourceMapping baseApkResourceMapping = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-R.txt" // baseApkResourceMapping = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-debug-R.txt" // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性 // **基准包这里最好是改成base-versionname,patch包就改成patch-versionname,每个版本的都不一样** tinkerId = "patch-1.0.1" // 构建多渠道补丁时使用 // buildAllFlavorsDir = "$&#123;bakPath&#125;/$&#123;baseApkDir&#125;" // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持） //tinker 1.7.8版本及以上版本// isProtectedApp = true // 是否开启反射Application模式 enableProxyApplication = false&#125;/** * 一般来说,我们无需对下面的参数做任何的修改 * 对于各参数的详细介绍请参考: * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 */tinkerPatch &#123; //oldApk ="$&#123;bakPath&#125;/$&#123;appName&#125;/app-release.apk" ignoreWarning = false useSign = true dex &#123; dexMode = "jar" pattern = ["classes*.dex"] loader = [] &#125; lib &#123; pattern = ["lib/*/*.so"] &#125; res &#123; pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"] ignoreChange = [] largeModSize = 100 &#125; packageConfig &#123; &#125; sevenZip &#123; zipArtifact = "com.tencent.mm:SevenZip:1.1.10"// path = "/usr/local/bin/7za" &#125; buildConfig &#123; keepDexApply = false //tinkerId = "1.0.1-base" //applyMapping = "$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-mapping.txt" // 可选，设置mapping文件，建议保持旧apk的proguard混淆方式 //applyResourceMapping = "$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-R.txt" // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配 &#125;&#125; 基准包一般都是以app-release.apk正式版，如果想要用debug版的话，上面的baseApk、baseApkProguardMapping、baseApkResourceMapping切换下。 全局配置: config.gradle12345678910ext.target_sdk_version = 27ext.min_sdk_version = 19ext.compile_sdk_version = 27ext.build_tools_version = '27.0.3'ext.support_library_version = '27.1.1'//TODO 调试模式的开启关闭ext.log_debug = falseext.version_code = 1ext.version_name = "1.0.1" 配置multiDexKeepBugly MultiDex注意事项，把Bugly的类放到主Dex,即写在multiDexKeep.pro 12-keep class com.tencent.bugly.** &#123;*;&#125;-keep class com.example.administrator.myapplication.AppLike&#123;*;&#125; 这里你的AppLike放在那里，对应修改其路径 附上项目目录结构图，在说明相对应的配置 配置XML权限、activity、provider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.example.administrator.myapplication"&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.READ_LOGS" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;application android:name=".App" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- Bugly --&gt; &lt;activity android:name="com.tencent.bugly.beta.ui.BetaActivity" android:configChanges="keyboardHidden|orientation|screenSize|locale" android:theme="@android:style/Theme.Translucent" /&gt; &lt;!-- Bugly --&gt; &lt;!-- 用于兼容7.0以上设备 --&gt; &lt;provider android:name=".MyFileProvider" android:authorities="$&#123;applicationId&#125;.fileProvider" android:exported="false" android:grantUriPermissions="true" tools:replace="name,authorities,exported,grantUriPermissions"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths" tools:replace="name,resource" /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; provider_paths.xml在res目录新建xml文件夹，创建provider_paths.xml文件如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;!--Bugly:这里配置的两个外部存储路径是升级SDK下载的文件可能存在的路径，一定要按照上面格式配置，不然可能会出现错误。--&gt; &lt;!-- /storage/emulated/0/Download/$&#123;applicationId&#125;/.beta/apk--&gt; &lt;external-path name="beta_external_path" path="Download/" /&gt; &lt;!--/storage/emulated/0/Android/data/$&#123;applicationId&#125;/files/apk/--&gt; &lt;external-path name="beta_external_files_path" path="Android/data/" /&gt; &lt;root-path name="root" path="root/" /&gt; &lt;!--代表设备的根目录new File("/");--&gt; &lt;files-path name="my_image" path="images/" /&gt; &lt;!--代表context.getFilesDir()--&gt; &lt;cache-path name="cache" path="caches/" /&gt; &lt;!--代表context.getCacheDir()--&gt; &lt;external-path name="my_dir" path="dirs/" /&gt; &lt;!--代表Environment.getExternalStorageDirectory()--&gt; &lt;!--&lt;external-files-path/&gt;--&gt; &lt;!--代表context.getExternalFilesDirs()--&gt; &lt;!--&lt;external-cache-path/&gt;--&gt; &lt;!--代表getExternalCacheDirs()--&gt;&lt;/paths&gt; 代码模块App.java12345678910111213141516171819public class App extends TinkerApplication &#123; public static App mInstance; public App() &#123; //同样修改成自己AppLike的路径 super(ShareConstants.TINKER_ENABLE_ALL, "com.example.administrator.myapplication.AppLike", "com.tencent.tinker.loader.TinkerLoader", false); &#125; public static App getInstance() &#123; return mInstance; &#125; @Override public void onCreate() &#123; super.onCreate(); mInstance = this; &#125;&#125; AppLike.java123456789101112131415161718192021222324252627282930313233343536373839404142public class AppLike extends DefaultApplicationLike &#123; public static final String TAG = "Tinker.AppLike"; public AppLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent); &#125; @Override public void onCreate() &#123; super.onCreate(); //设置自定义升级对话框UI布局 Beta.upgradeDialogLayoutId = R.layout.upgrade_dialog; //添加可显示弹窗的Activity Beta.canShowUpgradeActs.add(MainActivity.class); //TODO 初始化,AppID替换成平台上项目中产品信息的AppID Bugly.init(getApplication(), "AppID", BuildConfig.LOG_DEBUG); // Q：你们是怎么定义开发设备的？ // BitmapQrCodeDecoder：我们会提供接口Bugly.setIsDevelopmentDevice(getApplicationContext(), true);， // 我们后台就会将你当前设备识别为开发设备，如果设置为false则非开发设备，我们会根据这个配置进行策略控制。 Bugly.setIsDevelopmentDevice(getApplication(), BuildConfig.LOG_DEBUG); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); MultiDex.install(base); // 安装tinker // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法 Beta.installTinker(this); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) &#123; getApplication().registerActivityLifecycleCallbacks(callbacks); &#125;&#125; MyFileProvider.java这里要注意一下，AndroidManifest.xml中的FileProvider类是在support-v4包中的，检查你的工程是否引入该类库，项目中新建一个MyFileProvider.java 12public class MyFileProvider extends FileProvider &#123;&#125; 打包及发布的流程1、如果你还不知道怎么打包的话，可以看下图。如果知道的话可以看下如何打补丁包，双击一下等待数秒就打包好了。 2、打完包的apk跟补丁包文件目录 bakApk中app-xxx目录下的apk为基准包（可以用于官网中全量更新：发布新版本）patch目录下的patch_signed_7zip.apk为补丁包（可以用于官网热更新：发布新补丁） 3、打包需要修改配置如下 config.gradle ext.log_debug = falseext.version_code = 1ext.version_name = “1.0.1” tinker-support.gradle def baseApkDir = “app-0710-18-39-06”tinkerId = “patch-1.0.1” 项目版本打包，首先要确定如下配置 ext.log_debug = false //调试模式的开启关闭，正式包要改成falseext.version_code = 1ext.version_name = “1.0.1”tinkerId = “patch-1.0.1” // tinkerId=patch-version_name 点击上图中的assembleRelease进行打正式包，生成app-0710-18-39-06下的app-release.apk(这个就是正式包，也算是基准包)，然后把apk上传到bugly，如下图 图中第三步，可以修改更新提示框，例如：AppLike.class中的Beta.upgradeDialogLayoutId = R.layout.upgrade_dialog;只需在项目中新建一个布局，不过那些按钮等都要设置对应的tag，才会起作用，具体看Bugly Android 应用升级 SDK 高级配置 特别要注意的是：打包成功之后，最好把app-0710-18-39-06文件夹保存起来。为什么？ 比如现在版本上线，突然出现一个重大bug，这时候可以选择用热更新进行修复。你也不用重新多弄个版本，用户也不用去重新下载apk。 然后项目打补丁包，需要如下配置 def baseApkDir = “app-0710-18-39-06” 这里的app-0710-18-39-06就是刚刚说要保存的基准包对应的文件名 弄完之后就上传补丁包，如下图 一般确认无误的情况，下发范围都是选择全部设备。 如果你想选择开发设备进行补丁包测试的话，那么又要修改如下配置，首先修改 ext.log_debug = true。 打包app-0710-18-39-06（包1）：ext.log_debug = false（作为全部设备使用）打包app-0710-18-40-40（包2）：ext.log_debug = true（作为开发设备使用） 这两个app-××× 都是相继打包出来的，也就是上面说的保存包1的时候，顺便改为true打包出包2，两个都一起保存起来，然后才有以下补丁包的说法。 具体流程如如下，画得有点丑，凑合着看呗（宝图哦） 最后经过多轮测试，发现打补丁时，baseApkDir必须是认准基准包的。而tinkerid可以不用是patch-versionname,但必须不能与之前的tinkerid重复。 文章涉及到的Demo，已上传至github 这里遇到一个坑，就是发布app之后，被“强制停止了”，然后重启提示“启动策略失败”。 原来是下发上限跟激活上限的问题，修改成100w就ok了 以上都是本人的一些见解，如有误点请帮忙指正，谢谢！！ 看到这里的话，累了吧，分享个小姐姐给你认识]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bugly</tag>
      </tags>
  </entry>
</search>
